{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":["file:///home/pratik/code-linux/image-converter/src/app/api/convert/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport sharp from 'sharp';\nimport archiver from 'archiver';\nimport { PassThrough } from 'stream';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const formData = await request.formData();\n    const files = formData.getAll('file') as File[];\n    const format = formData.get('format') as string;\n    const quality = parseInt(formData.get('quality') as string) || 80;\n\n    // Validate inputs\n    if (!files || files.length === 0) {\n      return NextResponse.json(\n        { error: 'No files provided' },\n        { status: 400 }\n      );\n    }\n\n    if (!['avif', 'webp'].includes(format)) {\n      return NextResponse.json(\n        { error: 'Invalid format. Only AVIF and WebP are supported.' },\n        { status: 400 }\n      );\n    }\n\n    if (quality < 1 || quality > 100) {\n      return NextResponse.json(\n        { error: 'Quality must be between 1 and 100' },\n        { status: 400 }\n      );\n    }\n\n    // Create a PassThrough stream to pipe the ZIP archive\n    const zipStream = new PassThrough();\n\n    // Create the archive\n    const archive = archiver('zip', {\n      zlib: { level: 9 }\n    });\n\n    // Pipe archive data to the stream\n    archive.pipe(zipStream);\n\n    // Process each file and append to archive\n    for (const file of files) {\n      const arrayBuffer = await file.arrayBuffer();\n      const buffer = Buffer.from(arrayBuffer);\n\n      let convertedBuffer;\n      if (format === 'avif') {\n        convertedBuffer = await sharp(buffer)\n          .avif({ quality })\n          .toBuffer();\n      } else {\n        convertedBuffer = await sharp(buffer)\n          .webp({ quality })\n          .toBuffer();\n      }\n\n      // Determine filename for converted file\n      const originalName = file.name || 'file';\n      const baseName = originalName.replace(/\\.[^/.]+$/, '');\n      const convertedFileName = `${baseName}.${format}`;\n\n      // Append converted file to archive\n      archive.append(convertedBuffer, { name: convertedFileName });\n    }\n\n    // Finalize the archive\n    await archive.finalize();\n\n    // Convert PassThrough stream to ReadableStream for Next.js\n    const readableStream = new ReadableStream({\n      start(controller) {\n        zipStream.on('data', (chunk) => controller.enqueue(chunk));\n        zipStream.on('end', () => controller.close());\n        zipStream.on('error', (err) => controller.error(err));\n      }\n    });\n\n    // Return the ZIP archive as a stream response\n    return new NextResponse(readableStream, {\n      status: 200,\n      headers: {\n        'Content-Type': 'application/zip',\n        'Content-Disposition': `attachment; filename=\"converted_images.zip\"`,\n      },\n    });\n\n  } catch (error) {\n    console.error('Image conversion error:', error);\n    return NextResponse.json(\n      { error: 'Failed to convert images. Please try again.' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,QAAQ,SAAS,MAAM,CAAC;QAC9B,MAAM,SAAS,SAAS,GAAG,CAAC;QAC5B,MAAM,UAAU,SAAS,SAAS,GAAG,CAAC,eAAyB;QAE/D,kBAAkB;QAClB,IAAI,CAAC,SAAS,MAAM,MAAM,KAAK,GAAG;YAChC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAoB,GAC7B;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,CAAC;YAAC;YAAQ;SAAO,CAAC,QAAQ,CAAC,SAAS;YACtC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAoD,GAC7D;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,UAAU,KAAK,UAAU,KAAK;YAChC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAoC,GAC7C;gBAAE,QAAQ;YAAI;QAElB;QAEA,sDAAsD;QACtD,MAAM,YAAY,IAAI,qGAAA,CAAA,cAAW;QAEjC,qBAAqB;QACrB,MAAM,UAAU,CAAA,GAAA,mIAAA,CAAA,UAAQ,AAAD,EAAE,OAAO;YAC9B,MAAM;gBAAE,OAAO;YAAE;QACnB;QAEA,kCAAkC;QAClC,QAAQ,IAAI,CAAC;QAEb,0CAA0C;QAC1C,KAAK,MAAM,QAAQ,MAAO;YACxB,MAAM,cAAc,MAAM,KAAK,WAAW;YAC1C,MAAM,SAAS,OAAO,IAAI,CAAC;YAE3B,IAAI;YACJ,IAAI,WAAW,QAAQ;gBACrB,kBAAkB,MAAM,CAAA,GAAA,mGAAA,CAAA,UAAK,AAAD,EAAE,QAC3B,IAAI,CAAC;oBAAE;gBAAQ,GACf,QAAQ;YACb,OAAO;gBACL,kBAAkB,MAAM,CAAA,GAAA,mGAAA,CAAA,UAAK,AAAD,EAAE,QAC3B,IAAI,CAAC;oBAAE;gBAAQ,GACf,QAAQ;YACb;YAEA,wCAAwC;YACxC,MAAM,eAAe,KAAK,IAAI,IAAI;YAClC,MAAM,WAAW,aAAa,OAAO,CAAC,aAAa;YACnD,MAAM,oBAAoB,GAAG,SAAS,CAAC,EAAE,QAAQ;YAEjD,mCAAmC;YACnC,QAAQ,MAAM,CAAC,iBAAiB;gBAAE,MAAM;YAAkB;QAC5D;QAEA,uBAAuB;QACvB,MAAM,QAAQ,QAAQ;QAEtB,2DAA2D;QAC3D,MAAM,iBAAiB,IAAI,eAAe;YACxC,OAAM,UAAU;gBACd,UAAU,EAAE,CAAC,QAAQ,CAAC,QAAU,WAAW,OAAO,CAAC;gBACnD,UAAU,EAAE,CAAC,OAAO,IAAM,WAAW,KAAK;gBAC1C,UAAU,EAAE,CAAC,SAAS,CAAC,MAAQ,WAAW,KAAK,CAAC;YAClD;QACF;QAEA,8CAA8C;QAC9C,OAAO,IAAI,gIAAA,CAAA,eAAY,CAAC,gBAAgB;YACtC,QAAQ;YACR,SAAS;gBACP,gBAAgB;gBAChB,uBAAuB,CAAC,2CAA2C,CAAC;YACtE;QACF;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA8C,GACvD;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}